# 第15章_锁

事务的 隔离性 由这章讲述的 锁 来实现。

## 1. 概述

在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 并发操作进行控制 ，因此产生了 锁 。同时 锁机制 也为实现MySQL 的各个隔离级别提供了保证。 锁冲突 也是影响数据库 并发访问性能 的一个重要因素。所以锁对数据库而 言显得尤其重要，也更加复杂。

## 2. MySQL并发事务访问相同记录

并发事务访问相同记录的情况大致可以划分为3种：

### 2.1 读-读情况

**读-读** 情况，即并发事务相继 读取相同的记录 。读取操作本身不会对记录有任何影响，并不会引起什么 问题，所以允许这种情况的发生。

### 2.2 写-写情况

写-写 情况，即并发事务相继对相同的记录做出改动。

在这种情况下会发生 **脏写** 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务 相继对一条记录做改动时，需要让它们 **排队执行** ，这个排队的过程其实是通过 锁 来实现的。这个所谓 的锁其实是一个 **内存中的结构** ，在事务执行前本来是没有锁的，也就是说一开始是没有 **锁结构** 和记录进 行关联的，如图所示：

![image-20220906145637166](C:\Users\Yilin.Yang\AppData\Roaming\Typora\typora-user-images\image-20220906145637166.png)

当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 **锁结构** ，当没有的时候 就会在内存中生成一个 **锁结构** 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 **锁结构** 与之关联

![image-20220906145843247](C:\Users\Yilin.Yang\AppData\Roaming\Typora\typora-user-images\image-20220906145843247.png)

小结几种说法：

- 不加锁

意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。

- 获取锁成功，或者加锁成功

意思就是在内存中生成了对应的 **锁结构** ，而且锁结构的 **is_waiting** 属性为 **false** ，也就是事务 可以继续执行操作。

- 获取锁失败，或者加锁失败，或者没有获取到锁

意思就是在内存中生成了对应的 **锁结构** ，不过锁结构的 **is_waiting** 属性为 **true** ，也就是事务 需要等待，不可以继续执行操作。

### 2.3 读-写或写-读情况

**读-写** 或 **写-读** ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 **脏读** 、 不可重 复读 、 **幻读** 的问题。

各个数据库厂商对 **SQL标准** 的支持都可能不一样。比如MySQL在 **REPEATABLE READ** 隔离级别上就已经 解决了 **幻读** 问题。

### 2.4 并发问题的解决方案

怎么解决 **脏读** 、 **不可重复读** 、 **幻读** 这些问题呢？其实有两种可选的解决方案：

- 方案一：读操作利用多版本并发控制（ MVCC ，下章讲解），写操作进行 加锁 。

- 方案二：读、写操作都采用 **加锁** 的方式。
- 小结对比发现：
  - 采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 性能更高 。
  - 采用 加锁 方式的话， 读-写 操作彼此需要 排队执行 ，影响性能。

一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况 下，要求必须采用 加锁 的方式执行。下面就讲解下MySQL中不同类别的锁。

## 3. 锁的不同角度分类

锁的分类图，如下

![image-20220906155519021](C:\Users\Yilin.Yang\AppData\Roaming\Typora\typora-user-images\image-20220906155519021.png)

### 3.1 从数据操作的类型划分：读锁、写锁

**读锁** ：也称为 **共享锁** 、英文用 **S** 表示。针对同一份数据，多个事务的读操作可以同时进行而不会 互相影响，相互不阻塞的。

**写锁** ：也称为 **排他锁** 、英文用 **X** 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样 就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。

**需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。**

### 3.2 从数据操作的粒度划分：表级锁、页级锁、行锁

#### 1. 表锁（Table Lock）

① 表级别的S锁、X锁

在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级 别的 **S锁** 或者 **X锁** 的。在对某个表执行一些诸如 **ALTER TABLE 、 DROP TABLE** 这类的 **DDL** 语句时，其 他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务 中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行 **DDL** 语句也会 发生阻塞。这个过程其实是通过在 server层 使用一种称之为 **元数据锁** （英文名： **Metadata Locks** ， 简称 **MDL** ）结构来实现的。

一般情况下，不会使用InnoDB存储引擎提供的表级别的 **S锁** 和 **X锁** 。只会在一些特殊情况下，比方说 **崩 溃恢复** 过程中用到。比如，在系统变量 **autocommit=0，innodb_table_locks = 1** 时， **手动** 获取 InnoDB存储引擎提供的表t 的 **S锁** 或者 **X锁** 可以这么写：

- `LOCK TABLES t READ `：InnoDB存储引擎会对表 t 加表级别的 S锁 。

- `LOCK TABLES t WRITE `：InnoDB存储引擎会对表 t 加表级别的 X锁 。